---
import BestRoastLayout from "../layouts/BestRoastLayout.astro";
import { fetchGraphQL } from "../lib/api";
import GET_ALL_POSTS from "../lib/queries/getAllPosts";
import SINGLE_PAGE_QUERY_PREVIEW from "../lib/queries/singlePage";
import { organiseComments } from "../lib/utils";
import type { Comments as CommentsType, Page, Post } from "../types";

const variables = { id: "5614" };
let singlePage: Page | null = null;

try {
  const { page } = await fetchGraphQL(SINGLE_PAGE_QUERY_PREVIEW, variables);
  singlePage = page;
} catch (error) {
  console.error("Error fetching GraphQL data:", error);
}

if (!singlePage) {
  throw new Error("No single page data found");
}

const getTopRatedRoasts = async () => {
  const allPosts: Post[] = [];
  let hasNextPage = true;
  let endCursor: string | null = null;

  while (hasNextPage) {
    const variables = endCursor ? { after: endCursor } : {};
    const { posts } = await fetchGraphQL(GET_ALL_POSTS, variables);

    const filtered = posts.nodes.filter((post: Post) => {
      const area = post.areas?.nodes?.[0]?.name;
      const isClosed = post.closedDowns?.nodes[0]?.name || "";
      const rating = parseFloat(post.ratings?.nodes?.[0]?.name || "0");

      return area === "Central London" && !isClosed && !isNaN(rating);
    });

    allPosts.push(...filtered);
    hasNextPage = posts.pageInfo.hasNextPage;
    endCursor = posts.pageInfo.endCursor;
  }

  return allPosts
    .sort(
      (a, b) =>
        parseFloat(b.ratings?.nodes?.[0]?.name || "") -
        parseFloat(a.ratings?.nodes?.[0]?.name || "")
    )
    .slice(0, 5);
};

const topRated = await getTopRatedRoasts();
const threadedComments = organiseComments(singlePage.comments.nodes);
---

<BestRoastLayout
  pageTitle={singlePage.title}
  description={singlePage?.seo?.opengraphDescription}
  opengraphImage={singlePage?.seo?.opengraphImage?.sourceUrl}
  content={singlePage.content}
  topRated={topRated}
  threadedComments={threadedComments}
  postId={singlePage.pageId}
/>
